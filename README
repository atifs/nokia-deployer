# Withings Deployer

The deployer is the deployment service used by the Platform team at Withings (now part of Nokia Tech).
It is entirely built in-house because we couldn't find a suitable open-source self-hosted solution.
It powers about a hundred deployments per day during business hours, on more than a hundred hosts.
It is designed for simplicity, ease of operation (for sysadmins), and ease of use (for developers).

Its main focus is deploying application code stored in Git repositories.
It can optionally be integrated with a build system, and supports running scripts at various points during the deployment process to customize each deployment.
It can disable servers in the HAproxy load balancer during a deployment to perform a rolling upgrade without downtime.

It provides an audit trail for all deployments (who initiated the deployment, what was deployed...), and features fine-grained access control. For instance, you can allow the developers of a project to deploy it to the beta environment only during business hours, and allow only the sysdamins to deploy to production.

The deployer can be used either programatically by its API, or through the provided web interface built on top of the API.

Deploying the deployer itself is pretty simple: it connects to the target servers by SSH (agentless architecture), and only requires a SQLAlchemy compatible database (http://docs.sqlalchemy.org/en/latest/dialects/index.html, tested with MySQL and SQLite). It reads commit information directly from Git.
Additionally, the deployer comes with built-in support for active-active redundancy (behind a HTTP load balancer).

The principal alternative we are aware of is Teletraan (https://github.com/pinterest/teletraan) by Pinterest, which has a slightly different feature set, and is significantly more complex to operate, but supports much larger scale deployments. 

## Status

Withings has been using this project in production for more than one year, and we consider it stable.
However, the plugin interface is quite new and may not be flexible enough ; this part is subject to change.

For "historical" reasons, some parts of the code could use some cleanup. We have some unit test coverage, but that point could be improved too.
It is planned to package it as a standard Python package ; for now, you have to manually install dependencies.

The current documentation is very minimal. The UI has some rough edges but is fully functionnal.

The Beanstalkd dependency is historical and will be removed at some point.

We'll have to fix some of these points before releasing the code.

## Integration with your environment

The deployer does not provide authentification, only authorization. You have to write a small authentification plugin that talks with an existing backend to perform authentification.

Optionally, you can write plugins to integrate the deployer with a build system, or to send custom notifications.

See the `deployment.integrationexample` module to get started.

## Deployment

These instructions are for Ubuntu 14.04 ; adapt them to your actual operating system. The deployer only supports Linux environments.
Unless specified otherwise, you can install these requirements using `apt`.

The deployer needs a running Beanstalkd queue and a SQLAlchemy compatible database.
It assumes the user it is running as has SSH access to every target server.

### Requirements

PPA for nodejs:
 - echo 'deb https://deb.nodesource.com/node_4.x trusty main' > /etc/apt/sources.list.d/nodejs
 - curl -s https://deb.nodesource.com/gpgkey/nodesource.gpg.key | apt-key add -

Build:
 - nodejs & npm
 - gulp (sudo npm install -g gulp)

Test:
 - freezegun (pip install freezegun)

Runtime:
 - python-git
 - python-daemon
 - python-mysqldb
 - sqlalalchemy > 1.0 (pip install sqlalchemy)
 - ws4py (pip install ws4py)
 - enum34 if running on Python 2.7 (pip install enum34)
 - requests (pip install requests)
 - cherrypy (pip install requests)
 - bcrypt (apt-get install python-dev libssl-dev libffi-dev; pip install bcrypt)

### Build the frontend app

```
# Rename the file build.config.sample.js to build.config.js and edit it to match your environment.

npm install
gulp build
```

(When developing, you can set up a faster background build with `gulp dev`. The project will be built again each time you change a file.)

The result will be a JS file in `web/static/js/` and a HTML file in `web/static/html/`.

### Run the deployer

The deployer provides its own HTTP server, but you may want to run it behind a reverse proxy.

```
# An example configuration file is provided in daemon.sample.ini ; adapt as needed.

python server.py -f /etc/deployer/daemon.ini restart
```

## Tests & development

### Backend tests

```
bash tests/run_local_tests.sh
```

If you already are inside a suitable virtualenv, running `nosetests` is enough.

### Manual tests

The folder `deployment/tests/integration` contains scripts to help with manually testing various features of the deployer.

### Style

Some parts of the frontend code are old and do not follow modern React or ES6 best practices. Feel free to cleanup when you are working on these parts:
* use stateless components where possible
* clearer separation between presentational and logic components
* connect more components to Redux, rather than having a few root components passing state down
* remove unecessary use of refs (maybe use a form library?)
* use of ES6 syntax
* ...
